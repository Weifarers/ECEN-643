import numpy as np
import system_state as sys


# Creates a class for each of the final states we're concerned with.
class FinalState(object):
    def __init__(self, name, states):
        self.name = name
        self.states = states
        # We break down the states into 4 substates.
        # The first two substates involve the status of the generators:
        #   - G1/G2 are a pair of generators that must flow through a transmission line.
        #   - G3 is a solitary generator that is attached directly to the same bus as the load.
        self.g12_state = 0
        self.g3_state = 0
        # T refers to the status of the transmission line, aka how much generation is allowed through.
        self.t_state = 0
        # Finally, we consider how much load we must supply.
        self.l_state = 0
        # lol = Loss of Load, or whether or not our generation can supply the amount of load being demanded.
        self.lol = False
        # Gets the probability of being in that state.
        self.prob = 0
        # We also have a dictionary for transitions.
        self.transition = dict()


# Gets the values of the generation, transmission, and load, given a certain set of states.
def val_get(state):
    # Checks the status of G1/G2 first.
    g12 = 0
    if state.g12_state == 1:
        g12 = 150
    elif state.g12_state == 2:
        g12 = 75
    elif state.g12_state == 3:
        g12 = 0
    # Checks the status of G3.
    g3 = 0
    if state.g3_state == 1:
        g3 = 75
    elif state.g3_state == 2:
        g3 = 0
    # Checks the status of the transmission line.
    transmission = 0
    if state.t_state == 1:
        transmission = 200
    elif state.t_state == 2:
        transmission = 100
    elif state.t_state == 3:
        transmission = 0
    # Finally checks the load.
    load = 0
    if state.l_state == 1:
        load = 60
    elif state.l_state == 2:
        load = 105
    elif state.l_state == 3:
        load = 205
    elif state.l_state == 4:
        load = 105
    elif state.l_state == 5:
        load = 60
    # Returns the generation, transmission, and load.
    return g12, g3, transmission, load


# Checks whether or not there is a loss of load.
def lol_checker(state, g12, g3, transmission, load):
    # The total generation is the minimum between G1/G2 and the transmission, since there are two cases:
    #   - There is enough transmission to allow all of the power being generated by G1/G2 through
    #   - There is a bottleneck on how much transmission may be allowed through.
    generation = min(g12, transmission) + g3
    # There's two situations of interest:
    #   - If there is less generation than load, we have a loss of load.
    #   - If there is more (or equal) generation than load, we do not have a loss of load.
    if generation < load:
        state.lol = True
    elif generation >= load:
        state.lol = False
    # Returns the state with the updated loss of load checker.
    return state


# Generates the list of states.
def state_generator():
    # Initializes a list that we will fill with states.
    state_list = []
    # Iterates through all the possible states of G1/G2. Note that we have to go from 1 to 4, since range is not
    # inclusive of the last value. The same applies for all future uses of range.
    i = 1
    for a in range(1, 4):
        # Iterates through all the possible states of G3.
        for b in range(1, 3):
            # Iterates through all the possible states of the transmission.
            for c in range(1, 4):
                # Iterates through all the possible states of the load.
                for d in range(1, 6):
                    state_str = str(a) + str(b) + str(c) + str(d)
                    # Creates the state name, and a new object for that state.
                    temp_state = FinalState(i, state_str)
                    # Assigns the states of each component for that state.
                    temp_state.g12_state = a
                    temp_state.g3_state = b
                    temp_state.t_state = c
                    temp_state.l_state = d
                    # Gets the values associated with the component states.
                    g12, g3, transmission, load = val_get(temp_state)
                    # Updates the loss of load for the state.
                    temp_state = lol_checker(temp_state, g12, g3, transmission, load)
                    # Appends this state to the list of states we currently have.
                    state_list.append(temp_state)
                    # Updates the state number.
                    i += 1
    # Returns the filled list of states.
    return state_list


# Creates transition rate matrices.
def transition_rate(system):
    # Gets the number of states in the system, and initializes a zero matrix for the transition rate matrix.
    n = len(system.states)
    r_matrix = np.zeros((n, n))
    # Goes through each state in the system.
    for i in system.states:
        temp_state = system.states[i]
        # Gets the transition rates from that state, and adds it to to the r_matrix.
        for j in temp_state.transition:
            r_matrix[i - 1, j - 1] = temp_state.transition[j]
        # Constructs the diagonal terms by taking the negative of the sum of the off-diagonal terms in that row.
        r_matrix[i - 1, i - 1] = -sum(r_matrix[i - 1])
    # Returns the transition rate matrix.
    return r_matrix


# Calculates the steady state probabilities using the transition rate matrix.
def bpc(r_matrix):
    # Creates the b matrix, which is the transpose of the r matrix.
    b_mat = np.copy(np.transpose(r_matrix))
    # We set the first row to be all 1's, for the condition that the sum of the probabilities must be 1.
    # Technically, this can be done for any row, but for sake of simplicity, we'll focus only on the first row.
    b_mat[0, :] = 1
    # Create a C matrix, where all the elements are 0 except the first row, which is 1/
    c_mat = np.zeros(len(b_mat))
    c_mat[0] = 1
    # Solve the equation to get the steady state probabilities for each of our states.
    p_mat = np.linalg.solve(b_mat, c_mat)
    # Returns the steady state probability matrix.
    return p_mat


# Constructs a new system involving all 90 of our final states.
def sys_construct(state_list, g3_sys, g12_sys, t_sys, l_sys):
    full_sys = sys.System('Full System')
    num_state = len(state_list)
    # This creates a dictionary where each key is the state number, and the value is a string format of what
    # state the components are currently in.
    comp_list = dict()
    for i in range(num_state):
        comp_list[i] = state_list[i].states
    for i in range(num_state):
        # Looks at each individual state, and transitions each of the components.
        curr_state = state_list[i]
        # We empty the list of all transitions, since we're building this from scratch. This is to avoid any overlapping
        # transitions.
        curr_state.transition = dict()
        # Gets the indices for the component states, and grabs their properties from the corresponding system.
        # First looking at G1/G2
        g12_temp = curr_state.g12_state
        g12 = g12_sys.states[g12_temp]
        # Then grabbing G3's information.
        g3_temp = curr_state.g3_state
        g3 = g3_sys.states[g3_temp]
        # Then the transmission system information.
        t_temp = curr_state.t_state
        t = t_sys.states[t_temp]
        # Finally, looking at the load information.
        l_temp = curr_state.l_state
        load = l_sys.states[l_temp]
        # Goes through each instance of changes in G1/G2, and finds matching states with the new combination.
        for a in g12.transition:
            # Each new state as a result of that transition is given a string containing the new component states.
            temp_state = str(a) + str(g3.name) + str(t.name) + str(load.name)
            # We then look for the state with the matching component states, and add a transition to that.
            for state_num, state in comp_list.items():
                if temp_state == state:
                    curr_state.transition[state_num + 1] = g12.transition[a]
        # We repeat this process for changes in G3.
        for b in g3.transition:
            temp_state = str(g12.name) + str(b) + str(t.name) + str(load.name)
            for state_num, state in comp_list.items():
                if temp_state == state:
                    curr_state.transition[state_num + 1] = g3.transition[b]
        # And repeating this for changes in the transmission system.
        for c in t.transition:
            temp_state = str(g12.name) + str(g3.name) + str(c) + str(load.name)
            for state_num, state in comp_list.items():
                if temp_state == state:
                    curr_state.transition[state_num + 1] = t.transition[c]
        # And finally for the loads.
        for d in load.transition:
            temp_state = str(g12.name) + str(g3.name) + str(t.name) + str(d)
            for state_num, state in comp_list.items():
                if temp_state == state:
                    curr_state.transition[state_num + 1] = load.transition[d]
        full_sys.states[i + 1] = curr_state
    return full_sys


def main():
    # Gets the systems for G1/G2, G3, the transmission, and the load.
    g3_sys, g12_sys = sys.gen_info()
    t_sys = sys.transmission_info()
    l_sys = sys.load_info()
    # Generates a list of all potential combination of states.
    state_list = state_generator()
    # Goes through every state, and finds the probability of being in that state.
    for i in range(len(state_list)):
        state = state_list[i]
        # Gets the values of the component states.
        curr_g12 = state.g12_state
        curr_g3 = state.g3_state
        curr_t = state.t_state
        curr_l = state.l_state
        # Calculates the steady state probabilities by multiplying out all the probabilities of the components.
        state.prob = g12_sys.states[curr_g12].ss_prob * g3_sys.states[curr_g3].ss_prob * \
            t_sys.states[curr_t].ss_prob * l_sys.states[curr_l].ss_prob
    # Calculates the loss of load probability by summing up all the probabilities for states that have loss of load.
    # Initializes the loss of load probability.
    lolp = 0
    for i in range(len(state_list)):
        state = state_list[i]
        # Checks if the state has loss of load. If it does, add the probability of that state to the LOLP.
        if state.lol:
            lolp += state.prob
        else:
            continue
    # Now we calculate the frequency of failure.
    full_sys = sys_construct(state_list, g3_sys, g12_sys, t_sys, l_sys)
    # First we get the transition rate matrix, and the  probability matrix.
    r_matrix = transition_rate(full_sys)
    p_matrix = bpc(r_matrix)
    # We'll use the definition Frequency of Failure = U.bar(A).Q
    # First, we get a list of all the states that have a loss of load, and deem them as failure states.
    lol_list = []
    for i in range(len(state_list)):
        if full_sys.states[i + 1].lol:
            lol_list.append(i + 1)
        else:
            continue
    # Now we construct the U matrix, which has value 1 if the index is a failure state, and 0 otherwise.
    u_mat = np.zeros((1, len(state_list)))
    for i in range(len(state_list)):
        if i + 1 in lol_list:
            u_mat[:, i] = 1
    # Now we'll construct Q, which is the same vector as P, but has a 0 at indices corresponding to failure states.
    q_mat = np.copy(p_matrix)
    for i in range(len(state_list)):
        if i + 1 in lol_list:
            q_mat[i] = 0
    # Finally, the bar(a) matrix is the transpose of the transition rate matrix, but with all diagonals equal to 0.
    a_bar = np.copy(np.transpose(r_matrix))
    for i in range(len(state_list)):
        a_bar[i, i] = 0
    freq_fail = np.matmul(np.matmul(u_mat, a_bar), q_mat)
    print('LOLP = {:.4f}'.format(lolp))
    print('Frequency of Failure = {:.4f}/year'.format(freq_fail[0]*365))


if __name__ == '__main__':
    main()
